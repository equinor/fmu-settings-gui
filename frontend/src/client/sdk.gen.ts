// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as ClientOptions, TDataShape } from '@hey-api/client-axios';
import { client as _heyApiClient } from './client.gen';
import type { HealthHealthCheckData, HealthHealthCheckResponse, HealthV1HealthCheckData, HealthV1HealthCheckError, HealthV1HealthCheckResponse, MatchGetCoordinateSystemData, MatchGetCoordinateSystemError, MatchGetCoordinateSystemResponse, MatchGetStratigraphyData, MatchGetStratigraphyResponse, ProjectDeleteProjectSessionData, ProjectDeleteProjectSessionError, ProjectDeleteProjectSessionResponse, ProjectGetCacheData, ProjectGetCacheDiffData, ProjectGetCacheDiffResponse, ProjectGetCacheError, ProjectGetCacheResponse, ProjectGetCacheRevisionData, ProjectGetCacheRevisionResponse, ProjectGetGlobalConfigStatusData, ProjectGetGlobalConfigStatusResponse, ProjectGetLockStatusData, ProjectGetLockStatusError, ProjectGetLockStatusResponse, ProjectGetMappingsData, ProjectGetMappingsResponse, ProjectGetProjectData, ProjectGetProjectError, ProjectGetProjectResponse, ProjectGetRmsProjectsData, ProjectGetRmsProjectsError, ProjectGetRmsProjectsResponse, ProjectPatchAccessData, ProjectPatchAccessError, ProjectPatchAccessResponse, ProjectPatchMasterdataData, ProjectPatchMasterdataError, ProjectPatchMasterdataResponse, ProjectPatchModelData, ProjectPatchModelError, ProjectPatchModelResponse, ProjectPatchRmsCoordinateSystemData, ProjectPatchRmsCoordinateSystemResponse, ProjectPatchRmsData, ProjectPatchRmsError, ProjectPatchRmsResponse, ProjectPatchRmsStratigraphicFrameworkData, ProjectPatchRmsStratigraphicFrameworkResponse, ProjectPatchRmsWellsData, ProjectPatchRmsWellsResponse, ProjectPostCacheRestoreData, ProjectPostCacheRestoreResponse, ProjectPostGlobalConfigData, ProjectPostGlobalConfigResponse, ProjectPostInitProjectData, ProjectPostInitProjectError, ProjectPostInitProjectResponse, ProjectPostLockAcquireData, ProjectPostLockAcquireError, ProjectPostLockAcquireResponse, ProjectPostLockRefreshData, ProjectPostLockRefreshError, ProjectPostLockRefreshResponse, ProjectPostProjectData, ProjectPostProjectError, ProjectPostProjectResponse, ProjectPutMappingsData, ProjectPutMappingsResponse, RmsDeleteRmsProjectData, RmsDeleteRmsProjectError, RmsDeleteRmsProjectResponse, RmsGetCoordinateSystemData, RmsGetCoordinateSystemError, RmsGetCoordinateSystemResponse, RmsGetHorizonsData, RmsGetHorizonsError, RmsGetHorizonsResponse, RmsGetWellsData, RmsGetWellsError, RmsGetWellsResponse, RmsGetZonesData, RmsGetZonesError, RmsGetZonesResponse, RmsPostRmsProjectData, RmsPostRmsProjectResponse, SessionGetSessionData, SessionGetSessionError, SessionGetSessionResponse, SessionPatchAccessTokenData, SessionPatchAccessTokenError, SessionPatchAccessTokenResponse, SessionPostSessionData, SessionPostSessionError, SessionPostSessionResponse, SmdaGetHealthData, SmdaGetHealthError, SmdaGetHealthResponse, SmdaPostFieldData, SmdaPostFieldError, SmdaPostFieldResponse, SmdaPostMasterdataData, SmdaPostMasterdataResponse, SmdaPostStratUnitsData, SmdaPostStratUnitsResponse, UserGetUserData, UserGetUserError, UserGetUserResponse, UserPatchApiKeyData, UserPatchApiKeyError, UserPatchApiKeyResponse } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Removes a project .fmu directory from a session
 * This route simply removes (closes) a project .fmu directory from a session.
 * This has no other side effects on the session.
 */
export const projectDeleteProjectSession = <ThrowOnError extends boolean = false>(options?: Options<ProjectDeleteProjectSessionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).delete<ProjectDeleteProjectSessionResponse, ProjectDeleteProjectSessionError, ThrowOnError>({
        url: '/api/v1/project/',
        ...options
    });
};

/**
 * Returns the paths and configuration of the nearest project .fmu directory
 * If a project is not already attached to the session id it will be
 * attached after a call to this route. If one is already attached this
 * route will return data for the project .fmu directory again.
 */
export const projectGetProject = <ThrowOnError extends boolean = false>(options?: Options<ProjectGetProjectData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ProjectGetProjectResponse, ProjectGetProjectError, ThrowOnError>({
        url: '/api/v1/project/',
        ...options
    });
};

/**
 * Returns the path and configuration of the project .fmu directory at 'path'
 * Used for when a user selects a project .fmu directory in a directory not
 * found above the user's current working directory. Will overwrite the
 * project .fmu directory attached to a session if one exists. If not, it is
 * added to the session.
 */
export const projectPostProject = <ThrowOnError extends boolean = false>(options: Options<ProjectPostProjectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ProjectPostProjectResponse, ProjectPostProjectError, ThrowOnError>({
        url: '/api/v1/project/',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Checks if a valid global config exists at the default location.
 * Checks the global config at the default project location. If the global config
 * does not validate, or is not found, a failed status code is returned.
 */
export const projectGetGlobalConfigStatus = <ThrowOnError extends boolean = false>(options?: Options<ProjectGetGlobalConfigStatusData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ProjectGetGlobalConfigStatusResponse, unknown, ThrowOnError>({
        url: '/api/v1/project/global_config_status',
        ...options
    });
};

/**
 * Initializes a project .fmu directory at 'path' and returns its paths and configuration
 * If a project .fmu directory is already attached to the session, this will
 * switch to use the newly created .fmu directory.
 */
export const projectPostInitProject = <ThrowOnError extends boolean = false>(options: Options<ProjectPostInitProjectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ProjectPostInitProjectResponse, ProjectPostInitProjectError, ThrowOnError>({
        url: '/api/v1/project/init',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Loads the global config into the project masterdata.
 * Loads the global config into the project masterdata. If the global config does
 * not validate, or is not found, a failed status code is returned. The endpoint
 * takes an optional parameter, `path` as input: This should be given as a relative
 * path, relative to the project root. If provided, the global config is searched
 * for at this path. If not, the default project path will be used.
 */
export const projectPostGlobalConfig = <ThrowOnError extends boolean = false>(options?: Options<ProjectPostGlobalConfigData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ProjectPostGlobalConfigResponse, unknown, ThrowOnError>({
        url: '/api/v1/project/global_config',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Attempts to acquire the project lock for editing
 * Tries to upgrade the project session from read-only to editable by acquiring
 * the project lock. If the lock cannot be acquired the project remains read-only
 * and the last lock acquire error is recorded in the session.
 */
export const projectPostLockAcquire = <ThrowOnError extends boolean = false>(options?: Options<ProjectPostLockAcquireData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ProjectPostLockAcquireResponse, ProjectPostLockAcquireError, ThrowOnError>({
        url: '/api/v1/project/lock_acquire',
        ...options
    });
};

/**
 * Refreshes the project lock timeout
 * Explicitly refreshes the project lock timeout if the current session
 * holds the lock. This should be called when the user actively indicates they
 * want to continue editing (e.g., pressing an 'Edit' button in the GUI).
 *
 * Returns a message indicating whether the lock was successfully refreshed.
 */
export const projectPostLockRefresh = <ThrowOnError extends boolean = false>(options?: Options<ProjectPostLockRefreshData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ProjectPostLockRefreshResponse, ProjectPostLockRefreshError, ThrowOnError>({
        url: '/api/v1/project/lock_refresh',
        ...options
    });
};

/**
 * Returns the lock status and lock file contents
 * Returns information about the project lock including whether the current
 * session holds the lock and the contents of the lock file if it exists.
 * This is useful for debugging lock conflicts and showing users who has
 * the project locked.
 */
export const projectGetLockStatus = <ThrowOnError extends boolean = false>(options?: Options<ProjectGetLockStatusData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ProjectGetLockStatusResponse, ProjectGetLockStatusError, ThrowOnError>({
        url: '/api/v1/project/lock_status',
        ...options
    });
};

/**
 * Saves SMDA masterdata to the project .fmu directory
 * Saves masterdata from SMDA to the project .fmu directory.
 * If existing masterdata is present, it will be updated with the new masterdata.
 */
export const projectPatchMasterdata = <ThrowOnError extends boolean = false>(options: Options<ProjectPatchMasterdataData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<ProjectPatchMasterdataResponse, ProjectPatchMasterdataError, ThrowOnError>({
        url: '/api/v1/project/masterdata',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Saves model data to the project .fmu directory
 * Saves model data to the project .fmu directory.
 * If existing model data is present, it will be replaced by the new
 * model data.
 */
export const projectPatchModel = <ThrowOnError extends boolean = false>(options: Options<ProjectPatchModelData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<ProjectPatchModelResponse, ProjectPatchModelError, ThrowOnError>({
        url: '/api/v1/project/model',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Saves access data to the project .fmu directory
 * Saves access data to the project .fmu directory.
 * If existing access data is present, it will be replaced by the new
 * access data.
 */
export const projectPatchAccess = <ThrowOnError extends boolean = false>(options: Options<ProjectPatchAccessData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<ProjectPatchAccessResponse, ProjectPatchAccessError, ThrowOnError>({
        url: '/api/v1/project/access',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Gets the paths of RMS projects in this project directory
 * Returns a list of paths to RMS projects found in the current project directory.
 */
export const projectGetRmsProjects = <ThrowOnError extends boolean = false>(options?: Options<ProjectGetRmsProjectsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ProjectGetRmsProjectsResponse, ProjectGetRmsProjectsError, ThrowOnError>({
        url: '/api/v1/project/rms_projects',
        ...options
    });
};

/**
 * Saves the RMS project path and version in the project .fmu directory
 * Saves the RMS project path and version to the project .fmu directory.
 * The RMS version is set automatically based on the provided RMS project path.
 * If existing RMS project path and version are present, they will be
 * replaced by the new RMS project path and version.
 */
export const projectPatchRms = <ThrowOnError extends boolean = false>(options: Options<ProjectPatchRmsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<ProjectPatchRmsResponse, ProjectPatchRmsError, ThrowOnError>({
        url: '/api/v1/project/rms',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Saves the RMS coordinate system in the project .fmu directory
 * Saves the RMS coordinate system to the project .fmu directory.
 * Requires that the RMS project path has been set first via PATCH /project/rms.
 * If an existing coordinate system is present, it will be replaced.
 */
export const projectPatchRmsCoordinateSystem = <ThrowOnError extends boolean = false>(options: Options<ProjectPatchRmsCoordinateSystemData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<ProjectPatchRmsCoordinateSystemResponse, unknown, ThrowOnError>({
        url: '/api/v1/project/rms/coordinate_system',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Saves the RMS stratigraphic framework in the project .fmu directory
 * Saves the RMS stratigraphic framework (zones and horizons) to the project
 * .fmu directory. Requires that the RMS project path has been set first via
 * PATCH /project/rms. If existing zones or horizons are present, they will
 * be replaced.
 */
export const projectPatchRmsStratigraphicFramework = <ThrowOnError extends boolean = false>(options: Options<ProjectPatchRmsStratigraphicFrameworkData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<ProjectPatchRmsStratigraphicFrameworkResponse, unknown, ThrowOnError>({
        url: '/api/v1/project/rms/stratigraphic_framework',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Saves the RMS wells in the project .fmu directory
 * Saves the RMS wells to the project .fmu directory.
 * Requires that the RMS project path has been set first via PATCH /project/rms.
 * If existing wells are present, they will be replaced.
 */
export const projectPatchRmsWells = <ThrowOnError extends boolean = false>(options: Options<ProjectPatchRmsWellsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<ProjectPatchRmsWellsResponse, unknown, ThrowOnError>({
        url: '/api/v1/project/rms/wells',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * List cache revisions
 * Returns a list of revision filenames for the resource specified by the
 * `resource` query parameter. The filenames are used with
 * GET /cache/{revision_id}.
 */
export const projectGetCache = <ThrowOnError extends boolean = false>(options: Options<ProjectGetCacheData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ProjectGetCacheResponse, ProjectGetCacheError, ThrowOnError>({
        url: '/api/v1/project/cache',
        ...options
    });
};

/**
 * Get cache revision content
 * Retrieve the content of a specific cache revision.
 *
 * The revision_id should be a filename from the list returned by GET /cache
 * (e.g., 20260112T143045.123456Z-a1b2c3d4.json).
 *
 * The `resource` query parameter selects which resource cache to read.
 *
 * Returns the parsed JSON content from the cached file in the `data` field.
 */
export const projectGetCacheRevision = <ThrowOnError extends boolean = false>(options: Options<ProjectGetCacheRevisionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ProjectGetCacheRevisionResponse, unknown, ThrowOnError>({
        url: '/api/v1/project/cache/{revision_id}',
        ...options
    });
};

/**
 * Get diff between current resource and cache revision
 * Compare a resource file in the current project with a cached revision.
 *
 * The `resource` query parameter selects which resource to diff.
 * The response is a list of changes keyed by `field_path`.
 */
export const projectGetCacheDiff = <ThrowOnError extends boolean = false>(options: Options<ProjectGetCacheDiffData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ProjectGetCacheDiffResponse, unknown, ThrowOnError>({
        url: '/api/v1/project/cache/diff/{revision_id}',
        ...options
    });
};

/**
 * Restore a resource from a cache revision
 * Restore a resource from a cache revision (overwrites current resource).
 *
 * The current resource state is cached before overwriting (when present).
 *
 * The `resource` query parameter selects which resource to restore.
 *
 * **Example flow:**
 *
 * 1. Current resource is in state A
 * 2. Call restore with a revision from state B
 * 3. Your current state A is cached (when present)
 * 4. Resource is now in state B
 * 5. To undo: restore from the newly created cache entry (your state A backup)
 */
export const projectPostCacheRestore = <ThrowOnError extends boolean = false>(options: Options<ProjectPostCacheRestoreData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ProjectPostCacheRestoreResponse, unknown, ThrowOnError>({
        url: '/api/v1/project/cache/restore/{revision_id}',
        ...options
    });
};

/**
 * Returns mappings for a specific mapping type and system combination.
 * Retrieves mappings for the specified mapping_type, source_system, and
 * target_system from the project's .fmu directory.
 *
 * Mappings are returned grouped by target context (target_id/target_uuid).
 *
 * Example: GET /project/mappings/stratigraphy/rms/smda returns all
 * stratigraphy mappings from RMS to SMDA.
 */
export const projectGetMappings = <ThrowOnError extends boolean = false>(options: Options<ProjectGetMappingsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ProjectGetMappingsResponse, unknown, ThrowOnError>({
        url: '/api/v1/project/mappings/{mapping_type}/{source_system}/{target_system}',
        ...options
    });
};

/**
 * Updates mappings for a specific mapping type and system combination
 * Replaces mappings for the specified mapping_type, source_system, and
 * target_system in the project's .fmu directory.
 *
 * This operation only affects mappings for the specified system combination.
 * Mappings for other source/target combinations are preserved.
 *
 * The request body should contain a list of mapping objects.
 * The mappings will be validated for:
 * - Correct mapping_type, source_system, and target_system matching URL parameters
 * - No duplicate mappings (same source_id, source_uuid, target_id, target_uuid,
 * and relation_type)
 * - Valid group structure (at most one primary per target, all mappings share
 * the same target context)
 * - Valid data according to the mapping schema
 *
 * Example: PUT /project/mappings/stratigraphy/rms/smda updates only the
 * stratigraphy mappings from RMS to SMDA, leaving other mappings unchanged.
 */
export const projectPutMappings = <ThrowOnError extends boolean = false>(options: Options<ProjectPutMappingsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<ProjectPutMappingsResponse, unknown, ThrowOnError>({
        url: '/api/v1/project/mappings/{mapping_type}/{source_system}/{target_system}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Returns the user .fmu configuration
 * The user configuration can store API subscription keys or tokens. These are
 * obfuscated as '**********' when returned.
 */
export const userGetUser = <ThrowOnError extends boolean = false>(options?: Options<UserGetUserData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<UserGetUserResponse, UserGetUserError, ThrowOnError>({
        url: '/api/v1/user/',
        ...options
    });
};

/**
 * Saves an API key/token to the user .fmu configuration
 * Currently only known API's can be saved to the user .fmu configuration.
 * Arbitrary API key-value pairs cannot be saved. The currently known APIs are:
 *
 * smda_subscription
 */
export const userPatchApiKey = <ThrowOnError extends boolean = false>(options: Options<UserPatchApiKeyData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<UserPatchApiKeyResponse, UserPatchApiKeyError, ThrowOnError>({
        url: '/api/v1/user/api_key',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Fetches the current session state
 * Retrieves the latest session metadata.
 */
export const sessionGetSession = <ThrowOnError extends boolean = false>(options?: Options<SessionGetSessionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<SessionGetSessionResponse, SessionGetSessionError, ThrowOnError>({
        url: '/api/v1/session/',
        ...options
    });
};

/**
 * Creates a session for the user
 * When creating a session the application will ensure that the user
 * .fmu directory exists by creating it if it does not.
 *
 * If a session already exists when POSTing to this route, the new session
 * will preserve the access tokens from the old session. If the old session
 * had a project .fmu directory, it will also be added to the new session.
 * After migrating the state, the old session is destroyed.
 *
 * If no previous session exists, the application will attempt to find the
 * nearest project .fmu directory above the current working directory and
 * add it to the session if found. If not found, no project will be associated.
 *
 * The session cookie set by this route is required for all other
 * routes. Sessions are not persisted when the API is shut down.
 */
export const sessionPostSession = <ThrowOnError extends boolean = false>(options?: Options<SessionPostSessionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<SessionPostSessionResponse, SessionPostSessionError, ThrowOnError>({
        security: [
            {
                name: 'x-fmu-settings-api',
                type: 'apiKey'
            }
        ],
        url: '/api/v1/session/',
        ...options
    });
};

/**
 * Adds a known access token to the session
 * This route should be used to add a scoped access token to the current
 * session. The token applied via this route is typically a dependency for
 * other routes.
 */
export const sessionPatchAccessToken = <ThrowOnError extends boolean = false>(options: Options<SessionPatchAccessTokenData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<SessionPatchAccessTokenResponse, SessionPatchAccessTokenError, ThrowOnError>({
        url: '/api/v1/session/access_token',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Close the RMS project in the session
 * Close the RMS project that is currently open in the session.
 *
 * This removes the RMS project reference from the session. The project
 * should be closed when it is no longer needed to free up resources.
 */
export const rmsDeleteRmsProject = <ThrowOnError extends boolean = false>(options?: Options<RmsDeleteRmsProjectData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).delete<RmsDeleteRmsProjectResponse, RmsDeleteRmsProjectError, ThrowOnError>({
        url: '/api/v1/rms/',
        ...options
    });
};

/**
 * Open an RMS project and store it in the session
 * Open an RMS project and store it in the session.
 *
 * The RMS project path must be configured in the project's .fmu config file.
 * Once opened, the project remains open in the session until explicitly closed
 * or the session expires. This allows for efficient repeated access without
 * reopening the project each time.
 *
 * The endpoint takes an optional parameter, `rms_version`, as input. This can be
 * used to specify which version of RMS API that should be used when opening
 * the RMS project.
 */
export const rmsPostRmsProject = <ThrowOnError extends boolean = false>(options?: Options<RmsPostRmsProjectData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<RmsPostRmsProjectResponse, unknown, ThrowOnError>({
        url: '/api/v1/rms/',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get the zones from the open RMS project
 * Retrieve the zones from the currently open RMS project.
 *
 * This endpoint requires an RMS project to be open in the session.
 * Use the POST / endpoint first to open an RMS project.
 */
export const rmsGetZones = <ThrowOnError extends boolean = false>(options?: Options<RmsGetZonesData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<RmsGetZonesResponse, RmsGetZonesError, ThrowOnError>({
        url: '/api/v1/rms/zones',
        ...options
    });
};

/**
 * Get all horizons from the open RMS project
 * Retrieve all horizons from the currently open RMS project.
 *
 * This endpoint requires an RMS project to be open in the session.
 * Use the POST / endpoint first to open an RMS project.
 */
export const rmsGetHorizons = <ThrowOnError extends boolean = false>(options?: Options<RmsGetHorizonsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<RmsGetHorizonsResponse, RmsGetHorizonsError, ThrowOnError>({
        url: '/api/v1/rms/horizons',
        ...options
    });
};

/**
 * Get all wells from the open RMS project
 * Retrieve all wells from the currently open RMS project.
 *
 * This endpoint requires an RMS project to be open in the session.
 * Use the POST / endpoint first to open an RMS project.
 */
export const rmsGetWells = <ThrowOnError extends boolean = false>(options?: Options<RmsGetWellsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<RmsGetWellsResponse, RmsGetWellsError, ThrowOnError>({
        url: '/api/v1/rms/wells',
        ...options
    });
};

/**
 * Get the project coordinate system from the open RMS project
 * Retrieve the project coordinate system from the currently open RMS project.
 *
 * This endpoint requires an RMS project to be open in the session.
 * Use the POST / endpoint first to open an RMS project.
 */
export const rmsGetCoordinateSystem = <ThrowOnError extends boolean = false>(options?: Options<RmsGetCoordinateSystemData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<RmsGetCoordinateSystemResponse, RmsGetCoordinateSystemError, ThrowOnError>({
        url: '/api/v1/rms/coordinate_system',
        ...options
    });
};

/**
 * Checks whether or not the current session is capable of querying SMDA
 * A route to check whether the client is capable of querying SMDA APIs
 * with their current session. The requirements for querying the SMDA API via
 * this API are:
 *
 * 1. A valid session
 * 2. An SMDA subscription key in the user's .fmu API key configuration
 * 3. A valid SMDA access token scoped to SMDA's user_impersonation scope
 *
 * A successful response from this route indicates that all other routes on the
 * SMDA router can be used.
 */
export const smdaGetHealth = <ThrowOnError extends boolean = false>(options?: Options<SmdaGetHealthData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<SmdaGetHealthResponse, SmdaGetHealthError, ThrowOnError>({
        url: '/api/v1/smda/health',
        ...options
    });
};

/**
 * Searches for a field identifier in SMDA
 * A route to search SMDA for an field (asset) by its named identifier.
 *
 * This endpoint applies a projection to the SMDA query so that only the relevant
 * data is returned: an identifier known by SMDA and its corresponding UUID. The
 * UUID should be used by other endpoints required the collection of data by a
 * field, i.e. this route is a dependency for most other routes.
 *
 * The number of results (hits) and number of pages those results span over is also
 * returned in the result. This endpoint does not implement pagination. The
 * current expectation is that a user would refine their search rather than page
 * through different results.
 */
export const smdaPostField = <ThrowOnError extends boolean = false>(options: Options<SmdaPostFieldData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SmdaPostFieldResponse, SmdaPostFieldError, ThrowOnError>({
        url: '/api/v1/smda/field',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Retrieves masterdata for fields to be confirmed in the GUI
 * A route to gather prospective SMDA masterdata relevant to FMU.
 *
 * This route receives a list of valid field names and returns masterdata that
 * pertains to them. The field names should be valid as return from from the
 * `smda/field` routes.
 *
 * The data returned from this endpoint is meant to be confirmed by the user who
 * may need to do some additional selection or pruning based upon the model they
 * are working from.
 *
 * One example of this is changing the coordinate system. A model may use a
 * coordinate system different from the one set as the field's default coordinate
 * system in SMDA. To match the way this works on SMDA, every coordinate system
 * known to SMDA is returned.
 *
 * This endpoint does multiple calls to the SMDA API, any of which may possibly
 * fail. In any of these calls fails incomplete data will _not_ be returned; that
 * is, a successful code with partial data will not be returned.
 */
export const smdaPostMasterdata = <ThrowOnError extends boolean = false>(options: Options<SmdaPostMasterdataData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SmdaPostMasterdataResponse, unknown, ThrowOnError>({
        url: '/api/v1/smda/masterdata',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Retrieves stratigraphic units for a stratigraphic column
 * A route to gather stratigraphic units from SMDA for a specified
 * stratigraphic column.
 *
 * This route receives a valid stratigraphic column identifier
 * and returns stratigraphic units associated with it. The identifier
 * should be obtained from the `stratigraphic_columns` field in the
 * `smda/masterdata` response.
 */
export const smdaPostStratUnits = <ThrowOnError extends boolean = false>(options: Options<SmdaPostStratUnitsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SmdaPostStratUnitsResponse, unknown, ThrowOnError>({
        url: '/api/v1/smda/strat_units',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Match RMS zones to SMDA stratigraphic units
 * Match RMS stratigraphic zones to SMDA stratigraphic units using a
 * greedy matching algorithm based on name similarity.
 *
 * This endpoint automatically fetches:
 * - RMS zones from the project configuration
 * - SMDA stratigraphic units using the stratigraphic column identifier
 * from the project's masterdata configuration
 *
 * The algorithm uses token-sort ratio for flexible name matching
 * that allows different word ordering.
 *
 * Confidence levels:
 * - 'high': score > 80
 * - 'medium': score 50-80
 * - 'low': score < 50
 *
 * Requirements:
 * - Project config must contain rms.zones
 * - Project config must contain masterdata.smda.stratigraphic_column.identifier
 */
export const matchGetStratigraphy = <ThrowOnError extends boolean = false>(options?: Options<MatchGetStratigraphyData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<MatchGetStratigraphyResponse, unknown, ThrowOnError>({
        url: '/api/v1/match/stratigraphy',
        ...options
    });
};

/**
 * Match RMS coordinate system to SMDA coordinate systems
 * Match RMS coordinate system to SMDA coordinate system using
 * name similarity.
 *
 * This endpoint automatically fetches:
 * - RMS coordinate system from the project configuration
 * - SMDA coordinate system from the project's masterdata configuration
 *
 * The algorithm uses strict ratio matching for coordinate system names.
 *
 * Confidence levels:
 * - 'high': score > 80
 * - 'medium': score 50-80
 * - 'low': score < 50
 *
 * Requirements:
 * - Project config must contain rms.coordinate_system
 * - Project config must contain masterdata.smda.coordinate_system
 */
export const matchGetCoordinateSystem = <ThrowOnError extends boolean = false>(options?: Options<MatchGetCoordinateSystemData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<MatchGetCoordinateSystemResponse, MatchGetCoordinateSystemError, ThrowOnError>({
        url: '/api/v1/match/coordinate_system',
        ...options
    });
};

/**
 * A health check on the /v1 routes.
 * This route requires a valid session to return 200 OK. it can used to check if the user has a valid session.
 */
export const healthV1HealthCheck = <ThrowOnError extends boolean = false>(options?: Options<HealthV1HealthCheckData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<HealthV1HealthCheckResponse, HealthV1HealthCheckError, ThrowOnError>({
        url: '/api/v1/health',
        ...options
    });
};

/**
 * A health check on the application
 * This route requires no form of authentication or authorization. It can be used to check if the application is running and responsive.
 */
export const healthHealthCheck = <ThrowOnError extends boolean = false>(options?: Options<HealthHealthCheckData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<HealthHealthCheckResponse, unknown, ThrowOnError>({
        url: '/health',
        ...options
    });
};